import { Injectable } from '@angular/core';
import * as L from 'leaflet';

import { WorldGeoJsonService } from '@app/shared/services/map/world-geo-json.service';
import { isNil } from '@core/utils/type-checkers';

@Injectable()
export class MapService {
  private readonly MILLISECONDS_INTERVAL = 300;
  private readonly maps: Record<string, L.Map> = {};
  private geoLayers: Record<string, L.GeoJSON> = {};
  private readonly baseMap = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  private readonly defaultOpts: L.MapOptions = {
    attributionControl: false,
    center: [30, 0],
    zoom: 2
  };

  private filters: Record<string, { year: number; week: number }> = {};
  private max_score: number;
  private totalCountryData: Record<
    string,
    Array<{ country: string; count: number; year: number; week: number }>
  > = {};

  constructor(private readonly world: WorldGeoJsonService) {}

  createNewMapInstance(
    id: string,
    countryData: Array<{ country: string; count: number }>,
    options?: L.MapOptions
  ): L.Map {
    const map = L.map(id, { ...this.defaultOpts, ...options });

    this.addCartoLayerToMap(map);
    this.addResizeObserverToMap(id, map);

    const geoData = this.world.getWorldGeoJson(countryData);
    const MAX_SCORE = Math.max(...countryData.map((geo) => geo.count));

    L.geoJson(geoData as any, {
      style: (feature) => {
        const color = this.getColorFromScore(
          feature.properties.country,
          feature.properties.score,
          MAX_SCORE
        );
        return { fillOpacity: 0.5, weight: 1, color };
      }
    }).addTo(map);

    this.maps[id] = map;

    return map;
  }

  createNewMapInstanceAnimated(
    id: string,
    countryData: Array<{ country: string; count: number; year: number; week: number }>,
    options?: L.MapOptions
  ): L.Map {
    const map = L.map(id, { ...this.defaultOpts, ...options });

    this.addCartoLayerToMap(map);
    this.addResizeObserverToMap(id, map);

    this.maps[id] = map;

    this.filters[id] = { year: countryData[0].year, week: countryData[0].week };
    this.max_score = Math.max(...countryData.map((geo) => geo.count));
    this.totalCountryData[id] = [];

    this.gestionGeoJsonTimeout(id, countryData);

    return map;
  }

  private gestionGeoJsonTimeout(
    id: string,
    countryData: Array<{ country: string; count: number; year: number; week: number }>
  ): void {
    const map = this.maps[id];

    const updateGeoJsonLayer = () => {
      if (this.geoLayers[id] != null) {
        map.removeLayer(this.geoLayers[id]);
      }
      const data = countryData.filter(
        (d) => d.year === this.filters[id].year && d.week === this.filters[id].week
      );

      data.forEach((d) => {
        if (!this.totalCountryData[id].some((c) => c.country === d.country)) {
          this.totalCountryData[id].push(d);
        } else {
          const accData = this.totalCountryData[id].find((c) => c.country === d.country);
          this.totalCountryData[id] = this.totalCountryData[id].filter(
            (c) => c.country !== d.country
          );
          this.totalCountryData[id].push({ ...accData, count: accData.count + d.count });
        }
      });

      const geoData = this.world.getWorldGeoJson(this.totalCountryData[id]);

      this.geoLayers[id] = L.geoJson(geoData as any, {
        style: (feature) => {
          const color = this.getColorFromScore(
            feature.properties.country,
            feature.properties.score,
            this.max_score
          );
          return { fillOpacity: 0.5, weight: 1, color };
        }
      });

      this.geoLayers[id].addTo(map);

      if (this.filters[id].week === 52) {
        if (!countryData.some((d) => d.year === this.filters[id].year + 1)) {
          this.filters[id] = { year: countryData[0].year, week: countryData[0].week };
          this.totalCountryData[id] = [];
        } else {
          this.filters[id] = {
            year: this.filters[id].year + 1,
            week: countryData.some((d) => d.year === this.filters[id].year + 1 && d.week === 0)
              ? 0
              : 1
          };
        }
      } else {
        this.filters[id].week++;
      }
      this.gestionGeoJsonTimeout(id, countryData);
    };

    setTimeout(() => updateGeoJsonLayer(), this.MILLISECONDS_INTERVAL);
  }

  private addCartoLayerToMap(map: L.Map): void {
    const cartoLayer = L.tileLayer(
      'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
      {
        maxZoom: 20
      }
    );

    cartoLayer.addTo(map);
  }

  private addResizeObserverToMap(id: string, map: L.Map): void {
    const mapDiv = document.getElementById(id);
    const resizeObserver = new ResizeObserver(() => {
      map.invalidateSize();
    });

    resizeObserver.observe(mapDiv);
  }

  private getColorFromScore(country: string, score: number, scoreMax: number): string {
    const NUM_COLOR_INTERVALS = 9;
    const INTERVAL_COLORS = [
      'rgba(158,158,158,0.15)',
      'rgb(255,255,204)',
      'rgb(255,237,160)',
      'rgb(254,217,118)',
      'rgb(254,178,76)',
      'rgb(253,141,60)',
      'rgb(252,78,42)',
      'rgb(227,26,28)',
      'rgb(189,0,38)',
      'rgb(128,0,38)'
    ];

    if (isNil(score)) {
      return INTERVAL_COLORS[0];
    }

    const INTERVAL = scoreMax / NUM_COLOR_INTERVALS;

    if (score <= 0) {
      return INTERVAL_COLORS[0];
    }

    if (score >= INTERVAL * NUM_COLOR_INTERVALS) {
      return INTERVAL_COLORS[NUM_COLOR_INTERVALS];
    }

    for (let period = 0; period <= NUM_COLOR_INTERVALS - 1; period++) {
      if (score >= INTERVAL * period && score < INTERVAL * (period + 1)) {
        // @ts-ignore
        return INTERVAL_COLORS[period + 1];
      }
    }

    return INTERVAL_COLORS[0];
  }
}
